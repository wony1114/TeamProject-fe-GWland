{"ast":null,"code":"/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionGroup\n */\n'use strict';\n\nvar React = require('react');\n\nvar PropTypes = require('prop-types');\n\nvar createReactClass = require('create-react-class');\n\nvar difference = require('lodash.difference');\n\nvar keyBy = require('lodash.keyby');\n\nvar assign = require('object-assign');\n\nvar getChildMapping = function getChildMapping(children) {\n  return keyBy(React.Children.toArray(children), function (child) {\n    return child.key;\n  });\n};\n\nvar ReactTransitionGroupPlus = createReactClass({\n  displayName: 'ReactTransitionGroupPlus',\n  propTypes: {\n    component: PropTypes.any,\n    childFactory: PropTypes.func,\n    transitionMode: PropTypes.oneOf(['in-out', 'out-in', 'simultaneous']),\n    deferLeavingComponentRemoval: PropTypes.bool\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      component: 'span',\n      childFactory: function childFactory(arg) {\n        return arg;\n      },\n      transitionMode: 'simultaneous',\n      deferLeavingComponentRemoval: false\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      children: getChildMapping(this.props.children)\n    };\n  },\n  componentWillMount: function componentWillMount() {\n    this.currentlyEnteringOrEnteredKeys = {};\n    this.currentlyEnteringKeys = {};\n    this.currentlyEnteringPromises = {};\n    this.currentlyLeavingKeys = {};\n    this.currentlyLeavingPromises = {};\n    this.pendingEnterCallbacks = {};\n    this.pendingLeaveCallbacks = {};\n    this.deferredLeaveRemovalCallbacks = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n    this.cancel = null;\n  },\n  componentDidMount: function componentDidMount() {\n    var initialChildMapping = this.state.children;\n\n    for (var key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        this.performAppear(key);\n      }\n    }\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var nextChildMapping = getChildMapping(nextProps.children);\n    var prevChildMapping = this.state.children;\n    var mergedChildMapping = assign({}, prevChildMapping, nextChildMapping);\n    this.setState({\n      children: mergedChildMapping\n    });\n    var key;\n\n    for (key in nextChildMapping) {\n      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);\n\n      if (nextChildMapping[key] && (!hasPrev || this.currentlyLeavingKeys[key])) {\n        this.keysToEnter.push(key);\n      }\n    }\n\n    for (key in prevChildMapping) {\n      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n\n      if (prevChildMapping[key] && !hasNext) {\n        this.keysToLeave.push(key);\n      }\n    }\n\n    if (this.props.transitionMode === 'out-in') {\n      this.keysToEnter = difference(this.keysToEnter, this.keysToLeave);\n    } // If we want to someday check for reordering, we could do it here.\n\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    var keysToEnter = this.keysToEnter;\n    var keysToLeave = this.keysToLeave;\n\n    switch (this.props.transitionMode) {\n      case 'out-in':\n        this.keysToLeave = [];\n\n        if (keysToLeave.length) {\n          keysToLeave.forEach(this.performLeave);\n        } else {\n          this.keysToEnter = [];\n          keysToEnter.forEach(this.performEnter);\n        }\n\n        break;\n\n      case 'in-out':\n        this.keysToEnter = [];\n        this.keysToLeave = [];\n\n        if (keysToEnter.length) {\n          Promise.all(keysToEnter.map(this.performEnter)).then(function () {\n            keysToLeave.forEach(this.performLeave);\n          }.bind(this));\n        } else {\n          keysToLeave.forEach(this.performLeave);\n        }\n\n        break;\n\n      default:\n        this.keysToEnter = [];\n        this.keysToLeave = [];\n        keysToEnter.forEach(this.performEnter);\n        keysToLeave.forEach(this.performLeave);\n        break;\n    }\n  },\n  performAppear: function performAppear(key) {\n    this.currentlyEnteringOrEnteredKeys[key] = true;\n    var component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  },\n  _handleDoneAppearing: function _handleDoneAppearing(key) {\n    var component = this.refs[key];\n\n    if (component && component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    var currentChildMapping = getChildMapping(this.props.children);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  },\n  performEnter: function performEnter(key) {\n    if (this.currentlyEnteringKeys[key]) {\n      return this.currentlyEnteringPromises[key];\n    }\n\n    this.cancelPendingLeave(key);\n    var component = this.refs[key];\n\n    if (!component) {\n      return Promise.resolve();\n    }\n\n    this.currentlyEnteringOrEnteredKeys[key] = true;\n    this.currentlyEnteringKeys[key] = true;\n\n    var callback = this._handleDoneEntering.bind(this, key);\n\n    this.pendingEnterCallbacks[key] = callback;\n    var enterPromise = new Promise(function (resolve) {\n      if (component.componentWillEnter) {\n        component.componentWillEnter(resolve);\n      } else {\n        resolve();\n      }\n    }).then(callback);\n    this.currentlyEnteringPromises[key] = enterPromise;\n    return enterPromise;\n  },\n  _handleDoneEntering: function _handleDoneEntering(key) {\n    delete this.pendingEnterCallbacks[key];\n    delete this.currentlyEnteringPromises[key];\n    delete this.currentlyEnteringKeys[key];\n    this.deferredLeaveRemovalCallbacks.forEach(function (fn) {\n      fn();\n    });\n    this.deferredLeaveRemovalCallbacks = [];\n    var component = this.refs[key];\n\n    if (component && component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    var currentChildMapping = getChildMapping(this.props.children);\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key) && this.currentlyEnteringOrEnteredKeys[key]) {\n      // This was removed before it had fully entered. Remove it.\n      if (this.props.transitionMode !== 'in-out') {\n        this.performLeave(key);\n      }\n    }\n  },\n  performLeave: function performLeave(key) {\n    if (this.currentlyLeavingKeys[key]) {\n      //already leaving, let it finish\n      return this.currentlyLeavingPromises[key];\n    }\n\n    this.cancelPendingEnter(key);\n    var component = this.refs[key];\n\n    if (!component) {\n      return Promise.resolve();\n    }\n\n    this.currentlyLeavingKeys[key] = true;\n\n    var callback = this._handleDoneLeaving.bind(this, key);\n\n    this.pendingLeaveCallbacks[key] = callback;\n    var leavePromise = new Promise(function (resolve) {\n      if (component.componentWillLeave) {\n        component.componentWillLeave(resolve);\n      } else {\n        resolve();\n      }\n    }) // Note that this is somewhat dangerous b/c it calls setState()\n    // again, effectively mutating the component before all the work\n    // is done.\n    .then(callback);\n    this.currentlyLeavingPromises[key] = leavePromise;\n    return leavePromise;\n  },\n  _handleDoneLeaving: function _handleDoneLeaving(key) {\n    delete this.pendingLeaveCallbacks[key];\n    delete this.currentlyLeavingKeys[key];\n    delete this.currentlyLeavingPromises[key];\n    var component = this.refs[key];\n\n    if (component && component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    var currentChildMapping = getChildMapping(this.props.children);\n\n    var updateChildren = function updateChildren() {\n      this.setState(function (state) {\n        var newChildren = assign({}, state.children);\n        delete newChildren[key];\n        return {\n          children: newChildren\n        };\n      });\n    }.bind(this);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      // but only perform enter if currently animating out, not already animated out\n      if (this.props.transitionMode !== 'in-out') {\n        this.performEnter(key);\n      }\n    } else {\n      delete this.currentlyEnteringOrEnteredKeys[key];\n\n      if (this.props.deferLeavingComponentRemoval && this.props.transitionMode !== 'in-out') {\n        this.deferredLeaveRemovalCallbacks.push(updateChildren);\n        this.forceUpdate();\n      } else {\n        updateChildren();\n      }\n    }\n  },\n  cancelPendingLeave: function cancelPendingLeave(key) {\n    if (this.pendingLeaveCallbacks[key]) {\n      this.pendingLeaveCallbacks[key]();\n      delete this.pendingLeaveCallbacks[key];\n    }\n  },\n  cancelPendingEnter: function cancelPendingEnter(key) {\n    if (this.pendingEnterCallbacks[key]) {\n      this.pendingEnterCallbacks[key]();\n      delete this.pendingEnterCallbacks[key];\n    }\n  },\n  cleanProps: function cleanProps(props) {\n    delete props.component;\n    delete props.transitionMode;\n    delete props.childFactory;\n    delete props.deferLeavingComponentRemoval;\n    return props;\n  },\n  render: function render() {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    var childrenToRender = [];\n\n    for (var key in this.state.children) {\n      var child = this.state.children[key];\n\n      if (child) {\n        // You may need to apply reactive updates to a child as it is leaving.\n        // The normal React way to do it won't work since the child will have\n        // already been removed. In case you need this behavior you can provide\n        // a childFactory function to wrap every child, even the ones that are\n        // leaving.\n        childrenToRender.push(React.cloneElement(this.props.childFactory(child), {\n          ref: key,\n          key: key\n        }));\n      }\n    }\n\n    return React.createElement(this.props.component, this.cleanProps(assign({}, this.props)), childrenToRender);\n  }\n});\nmodule.exports = ReactTransitionGroupPlus;","map":{"version":3,"sources":["C:/Users/kang/Luna/GWproject/fe/node_modules/react-transition-group-plus/src/ReactTransitionGroupPlus.js"],"names":["React","require","PropTypes","createReactClass","difference","keyBy","assign","getChildMapping","children","Children","toArray","child","key","ReactTransitionGroupPlus","displayName","propTypes","component","any","childFactory","func","transitionMode","oneOf","deferLeavingComponentRemoval","bool","getDefaultProps","arg","getInitialState","props","componentWillMount","currentlyEnteringOrEnteredKeys","currentlyEnteringKeys","currentlyEnteringPromises","currentlyLeavingKeys","currentlyLeavingPromises","pendingEnterCallbacks","pendingLeaveCallbacks","deferredLeaveRemovalCallbacks","keysToEnter","keysToLeave","cancel","componentDidMount","initialChildMapping","state","performAppear","componentWillReceiveProps","nextProps","nextChildMapping","prevChildMapping","mergedChildMapping","setState","hasPrev","hasOwnProperty","push","hasNext","componentDidUpdate","length","forEach","performLeave","performEnter","Promise","all","map","then","bind","refs","componentWillAppear","_handleDoneAppearing","componentDidAppear","currentChildMapping","cancelPendingLeave","resolve","callback","_handleDoneEntering","enterPromise","componentWillEnter","fn","componentDidEnter","cancelPendingEnter","_handleDoneLeaving","leavePromise","componentWillLeave","componentDidLeave","updateChildren","newChildren","forceUpdate","cleanProps","render","childrenToRender","cloneElement","ref","createElement","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionGroup\n */\n\n'use strict';\n\nvar React = require('react');\nvar PropTypes = require('prop-types');\nvar createReactClass = require('create-react-class');\nvar difference = require('lodash.difference');\nvar keyBy = require('lodash.keyby');\n\nvar assign = require('object-assign');\n\nvar getChildMapping = function (children) {\n  return keyBy(\n    React.Children.toArray(\n      children\n    ),\n    function(child) {\n      return child.key;\n    }\n  );\n};\n\nvar ReactTransitionGroupPlus = createReactClass({\n  displayName: 'ReactTransitionGroupPlus',\n\n  propTypes: {\n    component: PropTypes.any,\n    childFactory: PropTypes.func,\n    transitionMode: PropTypes.oneOf(['in-out', 'out-in', 'simultaneous']),\n    deferLeavingComponentRemoval: PropTypes.bool,\n  },\n\n  getDefaultProps: function() {\n    return {\n      component: 'span',\n      childFactory: function (arg) {\n        return arg;\n      },\n      transitionMode: 'simultaneous',\n      deferLeavingComponentRemoval: false,\n    };\n  },\n\n  getInitialState: function() {\n    return {\n      children: getChildMapping(this.props.children),\n    };\n  },\n\n  componentWillMount: function() {\n    this.currentlyEnteringOrEnteredKeys = {};\n    this.currentlyEnteringKeys = {};\n    this.currentlyEnteringPromises = {};\n    this.currentlyLeavingKeys = {};\n    this.currentlyLeavingPromises = {};\n    this.pendingEnterCallbacks = {};\n    this.pendingLeaveCallbacks = {};\n    this.deferredLeaveRemovalCallbacks = [];\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n    this.cancel = null;\n  },\n\n  componentDidMount: function() {\n    var initialChildMapping = this.state.children;\n    for (var key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        this.performAppear(key);\n      }\n    }\n  },\n\n  componentWillReceiveProps: function(nextProps) {\n    var nextChildMapping = getChildMapping(\n      nextProps.children\n    );\n    var prevChildMapping = this.state.children;\n\n    var mergedChildMapping = assign({},\n      prevChildMapping,\n      nextChildMapping\n    );\n    this.setState({\n      children: mergedChildMapping\n    });\n\n    var key;\n\n    for (key in nextChildMapping) {\n      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);\n      if (nextChildMapping[key] && ( !hasPrev || this.currentlyLeavingKeys[key])) {\n        this.keysToEnter.push(key);\n      }\n    }\n\n    for (key in prevChildMapping) {\n      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n      if (prevChildMapping[key] && !hasNext ) {\n        this.keysToLeave.push(key);\n      }\n    }\n\n    if (this.props.transitionMode === 'out-in') {\n      this.keysToEnter = difference(this.keysToEnter, this.keysToLeave);\n    }\n\n    // If we want to someday check for reordering, we could do it here.\n  },\n\n  componentDidUpdate: function() {\n    var keysToEnter = this.keysToEnter;\n    var keysToLeave = this.keysToLeave;\n\n    switch (this.props.transitionMode) {\n      case 'out-in':\n        this.keysToLeave = [];\n        if (keysToLeave.length) {\n          keysToLeave.forEach(this.performLeave)\n        } else {\n          this.keysToEnter = [];\n          keysToEnter.forEach(this.performEnter)\n        }\n        break;\n      case 'in-out':\n        this.keysToEnter = [];\n        this.keysToLeave = [];\n\n        if (keysToEnter.length) {\n          Promise.all(keysToEnter.map(this.performEnter))\n            .then(function () {\n              keysToLeave.forEach(this.performLeave)\n            }.bind(this))\n        } else {\n          keysToLeave.forEach(this.performLeave)\n        }\n        break;\n      default:\n        this.keysToEnter = [];\n        this.keysToLeave = [];\n        keysToEnter.forEach(this.performEnter);\n        keysToLeave.forEach(this.performLeave);\n        break;\n    }\n  },\n\n  performAppear: function(key) {\n    this.currentlyEnteringOrEnteredKeys[key] = true;\n\n    var component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(\n        this._handleDoneAppearing.bind(this, key)\n      );\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  },\n\n  _handleDoneAppearing: function(key) {\n    var component = this.refs[key];\n    if (component && component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    var currentChildMapping = getChildMapping(\n      this.props.children\n    );\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  },\n\n  performEnter: function(key) {\n\n    if (this.currentlyEnteringKeys[key]) {\n      return this.currentlyEnteringPromises[key];\n    }\n\n    this.cancelPendingLeave(key);\n\n\n    var component = this.refs[key];\n\n    if (!component) {\n      return Promise.resolve();\n    }\n\n    this.currentlyEnteringOrEnteredKeys[key] = true;\n    this.currentlyEnteringKeys[key] = true;\n\n    var callback = this._handleDoneEntering.bind(this, key);\n    this.pendingEnterCallbacks[key] = callback;\n\n    var enterPromise = new Promise(function (resolve) {\n      if (component.componentWillEnter) {\n        component.componentWillEnter(resolve);\n      } else {\n        resolve();\n      }\n    }).then(callback);\n\n    this.currentlyEnteringPromises[key] = enterPromise;\n\n    return enterPromise;\n  },\n\n  _handleDoneEntering: function(key) {\n    delete this.pendingEnterCallbacks[key];\n    delete this.currentlyEnteringPromises[key];\n    delete this.currentlyEnteringKeys[key];\n\n    this.deferredLeaveRemovalCallbacks.forEach(function(fn) { fn(); });\n    this.deferredLeaveRemovalCallbacks = [];\n\n    var component = this.refs[key];\n    if (component && component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    var currentChildMapping = getChildMapping(\n      this.props.children\n    );\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key) && this.currentlyEnteringOrEnteredKeys[key]) {\n      // This was removed before it had fully entered. Remove it.\n\n      if (this.props.transitionMode !== 'in-out') {\n        this.performLeave(key);\n      }\n    }\n  },\n\n  performLeave: function(key) {\n    if (this.currentlyLeavingKeys[key]) {\n      //already leaving, let it finish\n      return this.currentlyLeavingPromises[key];\n    }\n\n    this.cancelPendingEnter(key);\n\n    var component = this.refs[key];\n\n    if (!component) {\n      return Promise.resolve();\n    }\n\n    this.currentlyLeavingKeys[key] = true;\n\n    var callback = this._handleDoneLeaving.bind(this, key);\n    this.pendingLeaveCallbacks[key] = callback;\n\n    var leavePromise = new Promise(function (resolve) {\n      if (component.componentWillLeave) {\n        component.componentWillLeave(resolve);\n      } else {\n        resolve();\n      }\n    })\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      .then(callback);\n\n    this.currentlyLeavingPromises[key] = leavePromise;\n    return leavePromise;\n  },\n\n  _handleDoneLeaving: function(key) {\n    delete this.pendingLeaveCallbacks[key];\n    delete this.currentlyLeavingKeys[key];\n    delete this.currentlyLeavingPromises[key];\n\n    var component = this.refs[key];\n\n    if (component && component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n\n    var currentChildMapping = getChildMapping(\n      this.props.children\n    );\n\n    var updateChildren = function updateChildren () {\n      this.setState(function(state) {\n        var newChildren = assign({}, state.children);\n        delete newChildren[key];\n        return {children: newChildren};\n      });\n    }.bind(this);\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      // but only perform enter if currently animating out, not already animated out\n      if (this.props.transitionMode !== 'in-out') {\n        this.performEnter(key);\n      }\n    } else {\n      delete this.currentlyEnteringOrEnteredKeys[key];\n\n      if (this.props.deferLeavingComponentRemoval && this.props.transitionMode !== 'in-out') {\n        this.deferredLeaveRemovalCallbacks.push(updateChildren);\n        this.forceUpdate();\n      } else {\n        updateChildren();\n      }\n    }\n  },\n\n  cancelPendingLeave: function (key) {\n    if (this.pendingLeaveCallbacks[key]) {\n      this.pendingLeaveCallbacks[key]();\n      delete this.pendingLeaveCallbacks[key];\n    }\n  },\n\n  cancelPendingEnter: function (key) {\n    if (this.pendingEnterCallbacks[key]) {\n      this.pendingEnterCallbacks[key]();\n      delete this.pendingEnterCallbacks[key];\n    }\n  },\n\n  cleanProps: function(props) {\n    delete props.component;\n    delete props.transitionMode;\n    delete props.childFactory;\n    delete props.deferLeavingComponentRemoval;\n    return props;\n  },\n\n  render: function() {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    var childrenToRender = [];\n    for (var key in this.state.children) {\n      var child = this.state.children[key];\n      if (child) {\n        // You may need to apply reactive updates to a child as it is leaving.\n        // The normal React way to do it won't work since the child will have\n        // already been removed. In case you need this behavior you can provide\n        // a childFactory function to wrap every child, even the ones that are\n        // leaving.\n        childrenToRender.push(React.cloneElement(\n          this.props.childFactory(child),\n          {ref: key, key: key}\n        ));\n      }\n    }\n    return React.createElement(\n      this.props.component,\n      this.cleanProps(assign({},this.props)),\n      childrenToRender\n    );\n  },\n});\n\nmodule.exports = ReactTransitionGroupPlus;\n"]},"metadata":{},"sourceType":"script"}